The task is to simulates the generation of data from several sensor(rangers) types, and performs data fusion.

Users will have to initiate the sensors they wish to use within the main and then using the varius set functions available in the \hyperlink{ranger_8h_source}{ranger.\+h} class header, they can then set the various parameters they wish to change. These sensors should then be passed into a vector which itself is passed to the \hyperlink{classRangerFusion}{Ranger\+Fusion} class constructor. Once the code is run, the user will be prompted to input the number of cells they wish to create to be checked by the sensors created beforehand. The sensors will then randomly generate data based on the inputed variables and its specifications, and that data will be run through the Graband\+Fuse\+Data function which determines based on the sensor readings whether a cell is free, occupied or unkown. This is achieved in a few ways depending on the sensor. Much of the implementation for the following is found within the \hyperlink{analysis_8h}{analysis.\+h} header and its coressponding analysis.\+cpp file.

For laser sensors, the process for determining cell states is rather simple. For example, a laser with a F\+OV of 180 degrees and a angular resolution of 30 degrees will produce 8 readings, starting from 0 degrees and incrementing by 30 till reaching 180. Since the length of each reading is known and the angle from a specfic reading and the x axis can be found, the coordinates for each reading can be found by splitting the vector into its vertical and horizontal components. From here its a simple case of checking wether these coordinates exists within the bounds of a cells sides, which can be found since the cell centre and side lengths can be obtained from the cell class. If this case proves true then the cell is O\+C\+C\+U\+P\+I\+ED. A cell is F\+R\+EE if the line between the laser centre and its reading passed through the sides of a cell but D\+O\+ES N\+OT stop within the cell itself. This can be determined using a line intersection algorithm.

In the case of a sonar, the check is a little more complicated. For a cell to be determined as O\+C\+C\+U\+P\+I\+ED by a sonar, a different approach had to be taken. In my case, I split the curve of the cone into many points separated by the same degree. Since the angle and radius of the sonar can be obtained, by similar methods used for the laser, these points along the curve can be found in cartesian coordinates. By obtaining enough of these points along the curve and checking if any of them exist in the space within the cell, it can be determined to be O\+C\+C\+U\+P\+I\+ED. For a cell to be found as free by a sonar, firstly the case if it is O\+C\+C\+U\+P\+I\+ED is checked. If it has not been set as O\+C\+C\+U\+P\+I\+ED a different check is performed. We take each corner of the cell and determine its distance from the sonar start. If the distance is smaller than that of the sonar reading, the corner may be inside the sonar bounds. If this first condition is met, another check is made. The corner must exist within the angles made by the 2 sonar edges in relation to the +x axis. To explain better consider this example; A sonar at the origin with a reading of 5, facing forwards along the +y axis with a F\+OV of 20 degrees, has its two edges at 80 and 100 degrees from the +x axis. A cell corner is said to be within the sonar bounds O\+N\+LY if its distance to the sonar start is less then 5 A\+ND its angle with the +x axis is less than 100 but more than 80 degrees. If one of the cell corners is in these bounds A\+ND it has N\+OT been set to O\+C\+C\+U\+P\+I\+ED it must be then F\+R\+EE.

The process to calculate the union of sonar area is a fairly laborious but can be explained in a step like manner;
\begin{DoxyEnumerate}
\item Firstly, the sonars are modeled as triangles for this task. All the points of intersection of sonar edges must be located, if there are any. This can be done by taking the 4 points that make up the 2 lines AB and CD, and running them through a generic point of intersection algorithm. The one used returns the points of intersection O\+N\+LY IF it lies on the length of the line made by the sonar edge and not outside of its bounds.
\item We check each sonar edge against each other sonar edge. I.\+e for 2 sonars, there will be 9 combinations of checks. Once all the P\+O\+Is are found they are stored in a vector along with the corners of the sonar which have intersected. N\+O\+TE\+: Sonars which DO N\+OT intersect with any other sonar do not have their corners stored and instead have their area calculated independantly from those that do since they are essentially isolated shapes.
\item From all of these P\+O\+Is and corners, those that are W\+I\+T\+H\+IN the area bounded by a sonar must be removed since they do not contribute to making up the overall shape of the polygon made by the intersecting triangle.
\item Now these left over points, which should be only those that make up the vertices of the polygon, have to be ordered in a counter clock wise fashion since the formula used to calculate the area of the polygon, does so taking points in a C\+CW manner. So these points are run through a bubble sort algorithm which compares a point R with a line made by the origin and point Q, by finding the orienatation of the ordered triplet. If point R is found to be clockwise of this line, it swapped with point Q.
\item Once all points are ordered, they can then be run through the formula and any isolated areas added on top to give a complete union of all sonar areas.
\end{DoxyEnumerate}

~\newline
 By Joseph Seklawy ~\newline
 \href{mailto:joseph.seklawy@student.uts.edu.au}{\tt joseph.\+seklawy@student.\+uts.\+edu.\+au} 